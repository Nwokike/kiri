"""
Gist Service for Traffic Controller
Creates and manages GitHub Gists for Binder and Colab integration.
"""

import os
import json
import logging
import requests
from typing import Optional

logger = logging.getLogger(__name__)


class GistService:
    """Creates and manages GitHub Gists for project execution."""
    
    GITHUB_API_URL = "https://api.github.com/gists"
    
    @classmethod
    def _get_auth_headers(cls) -> dict:
        """Get GitHub API headers with authentication."""
        token = os.environ.get('KIRI_BOT_GITHUB_TOKEN')
        if not token:
            raise ValueError("KIRI_BOT_GITHUB_TOKEN environment variable not set")
        
        return {
            "Authorization": f"token {token}",
            "Accept": "application/vnd.github.v3+json",
            "Content-Type": "application/json"
        }
    
    @classmethod
    def create_binder_gist(cls, project) -> Optional[str]:
        """
        Creates a Gist with Binder configuration files.
        
        The Gist includes:
        - requirements.txt with user deps + jupyter-server-proxy
        - postBuild script to clone the user's repo
        - start script to launch the app
        
        Returns:
            Gist ID string, or None on failure
        """
        from projects.services import GitHubService
        
        # Parse repo info
        parsed = GitHubService.parse_repo_url(project.github_repo_url)
        if not parsed:
            logger.error(f"Failed to parse repo URL: {project.github_repo_url}")
            return None
        
        owner, repo = parsed
        
        # Fetch existing requirements.txt from the repo (if any)
        existing_requirements = cls._fetch_repo_file(owner, repo, 'requirements.txt')
        
        # Build requirements.txt with jupyter-server-proxy
        requirements_content = "# Auto-generated by Kiri Research Labs\n"
        requirements_content += "jupyter-server-proxy\n"
        if existing_requirements:
            requirements_content += f"\n# Original requirements from {owner}/{repo}\n"
            requirements_content += existing_requirements
        
        # postBuild script - runs after container build
        postbuild_content = f"""#!/bin/bash
# Clone the user's repository
git clone https://github.com/{owner}/{repo}.git /home/jovyan/project
cd /home/jovyan/project
# Install project-specific dependencies if they exist
if [ -f requirements.txt ]; then
    pip install -r requirements.txt
fi
"""
        
        # start script - runs when container starts
        start_command = project.start_command or 'python app.py'
        start_content = f"""#!/bin/bash
cd /home/jovyan/project
{start_command}
"""
        
        # Create the Gist
        gist_data = {
            "description": f"Binder config for {owner}/{repo} - via Kiri Research Labs",
            "public": True,
            "files": {
                "requirements.txt": {"content": requirements_content},
                "postBuild": {"content": postbuild_content},
                "start": {"content": start_content}
            }
        }
        
        try:
            response = requests.post(
                cls.GITHUB_API_URL,
                headers=cls._get_auth_headers(),
                json=gist_data,
                timeout=30
            )
            
            if response.status_code == 201:
                gist_id = response.json()['id']
                logger.info(f"Created Binder Gist: {gist_id}")
                return gist_id
            else:
                logger.error(f"Failed to create Gist: {response.status_code} - {response.text[:200]}")
                return None
                
        except Exception as e:
            logger.error(f"Gist creation error: {e}")
            return None
    
    @classmethod
    def create_colab_gist(cls, project, notebook_content: str) -> Optional[str]:
        """
        Creates a Gist with a Colab notebook.
        
        Args:
            project: Project instance
            notebook_content: JSON string of the .ipynb notebook
            
        Returns:
            Gist ID string, or None on failure
        """
        from projects.services import GitHubService
        
        parsed = GitHubService.parse_repo_url(project.github_repo_url)
        if not parsed:
            return None
        
        owner, repo = parsed
        
        gist_data = {
            "description": f"Colab notebook for {owner}/{repo} - via Kiri Research Labs",
            "public": True,
            "files": {
                "demo.ipynb": {"content": notebook_content}
            }
        }
        
        try:
            response = requests.post(
                cls.GITHUB_API_URL,
                headers=cls._get_auth_headers(),
                json=gist_data,
                timeout=30
            )
            
            if response.status_code == 201:
                gist_id = response.json()['id']
                logger.info(f"Created Colab Gist: {gist_id}")
                return gist_id
            else:
                logger.error(f"Failed to create Gist: {response.status_code} - {response.text[:200]}")
                return None
                
        except Exception as e:
            logger.error(f"Gist creation error: {e}")
            return None
    
    @classmethod
    def build_binder_url(cls, gist_id: str, port: int = 8000) -> str:
        """
        Builds the mybinder.org URL for a Gist.
        
        Args:
            gist_id: GitHub Gist ID
            port: Port number the app runs on (default 8000)
            
        Returns:
            Full Binder launch URL with proxy redirect
        """
        username = os.environ.get('KIRI_BOT_USERNAME', 'kiri-labs-bot')
        return f"https://mybinder.org/v2/gist/{username}/{gist_id}/HEAD?urlpath=proxy/{port}/"
    
    @classmethod
    def build_colab_url(cls, gist_id: str) -> str:
        """
        Builds the Google Colab URL for a Gist-hosted notebook.
        
        Args:
            gist_id: GitHub Gist ID
            
        Returns:
            Full Colab launch URL
        """
        username = os.environ.get('KIRI_BOT_USERNAME', 'kiri-labs-bot')
        return f"https://colab.research.google.com/gist/{username}/{gist_id}/demo.ipynb"
    
    @classmethod
    def _fetch_repo_file(cls, owner: str, repo: str, filepath: str) -> Optional[str]:
        """
        Fetches a file from a GitHub repository.
        
        Returns:
            File content as string, or None if not found
        """
        url = f"https://raw.githubusercontent.com/{owner}/{repo}/HEAD/{filepath}"
        
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                return response.text
        except Exception as e:
            logger.debug(f"Could not fetch {filepath}: {e}")
        
        return None
    
    @classmethod
    def delete_gist(cls, gist_id: str) -> bool:
        """
        Deletes a Gist by ID.
        
        Returns:
            True if deleted successfully
        """
        try:
            response = requests.delete(
                f"{cls.GITHUB_API_URL}/{gist_id}",
                headers=cls._get_auth_headers(),
                timeout=30
            )
            return response.status_code == 204
        except Exception as e:
            logger.error(f"Gist deletion error: {e}")
            return False
